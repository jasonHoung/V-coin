# 反作弊機制設計

## 一、作弊類型分析

### 1.1 常見作弊方式

| 作弊類型 | 描述 | 風險等級 |
|---------|------|---------|
| 假裝執行 | 不執行任務，直接返回隨機結果 | 高 |
| 結果複製 | 複製其他節點的結果 | 高 |
| 低品質執行 | 降低運算精度以提升速度 | 中 |
| 虛報 GPU | 聲稱有高階 GPU 但實際使用低階 | 中 |
| 女巫攻擊 | 單一實體控制多個節點 | 低 |
| 時間作弊 | 預先知道任務內容 | 低 |

## 二、任務抽樣驗證

### 2.1 驗證策略

```python
class SamplingValidator:
    def __init__(self):
        self.base_rate = 0.1  # 基礎抽樣率 10%
        
    def should_validate(self, node_id, task):
        """動態決定是否驗證"""
        reputation = get_reputation(node_id)
        
        # 低信譽節點提高驗證率
        if reputation < 70:
            validate_rate = 0.5
        elif reputation < 85:
            validate_rate = 0.2
        else:
            validate_rate = self.base_rate
        
        # 高價值任務必定驗證
        if task.payment > 10:
            validate_rate = 1.0
        
        return random.random() < validate_rate
    
    def validate_task(self, original_task, original_result):
        """重新執行驗證"""
        # 選擇不同的高信譽節點
        validator_node = self.select_validator(
            exclude=[original_task.node_id],
            min_reputation=90
        )
        
        # 建立驗證任務（參數完全相同）
        verify_task = {
            'type': 'verification',
            'original_task_id': original_task.id,
            'model': original_task.model,
            'input': original_task.input,
            'params': original_task.params
        }
        
        # 分配驗證任務
        verify_result = assign_and_wait(validator_node, verify_task)
        
        # 比對結果
        return self.compare_results(original_result, verify_result)
```

### 2.2 結果比對演算法

```python
def compare_results(result_a, result_b, task_type):
    """根據任務類型使用不同的比對方式"""
    
    if task_type == 'text_generation':
        # 文字生成：使用語義相似度
        similarity = compute_semantic_similarity(
            result_a.text, 
            result_b.text
        )
        threshold = 0.85  # 允許一定差異
        
    elif task_type == 'image_generation':
        # 圖像生成：使用 SSIM
        similarity = compute_ssim(
            result_a.image, 
            result_b.image
        )
        threshold = 0.90
        
    elif task_type == 'classification':
        # 分類任務：必須完全一致
        similarity = 1.0 if result_a.label == result_b.label else 0.0
        threshold = 1.0
        
    elif task_type == 'embedding':
        # 嵌入向量：使用餘弦相似度
        similarity = cosine_similarity(
            result_a.vector, 
            result_b.vector
        )
        threshold = 0.95
    
    return similarity >= threshold, similarity
```

## 三、Hidden Validation（隱藏驗證）

### 3.1 測試任務設計

```python
class HiddenValidator:
    def __init__(self):
        self.test_pool = self.load_test_cases()
        self.injection_rate = 0.05  # 5% 任務為測試
        
    def inject_test_task(self, task_queue):
        """隨機注入測試任務"""
        if random.random() < self.injection_rate:
            test_case = self.select_test_case(task_queue.task_type)
            
            # 偽裝成正常任務
            fake_task = {
                'id': generate_fake_id(),
                'type': task_queue.task_type,
                'model': test_case.model,
                'input': test_case.input,
                'is_test': True,  # 內部標記，節點看不到
                'expected_output': test_case.output
            }
            
            task_queue.add(fake_task)
    
    def validate_test_result(self, task_id, result):
        """驗證測試任務結果"""
        test_case = self.get_test_case(task_id)
        
        match_score = self.compare_with_expected(
            result, 
            test_case.expected_output
        )
        
        if match_score < 0.9:
            # 未通過測試
            node_id = get_node_for_task(task_id)
            self.report_cheating(node_id, 'failed_hidden_test')
            
        return match_score
```

### 3.2 測試案例庫

```python
# 測試案例範例
TEST_CASES = {
    'llm_inference': [
        {
            'model': 'llama-7b',
            'input': '請用一句話介紹人工智慧',
            'expected_keywords': ['人工智慧', '模擬', '智能'],
            'min_length': 20
        },
        {
            'model': 'llama-7b',
            'input': '1 + 1 = ?',
            'expected_output': '2',
            'exact_match': True
        }
    ],
    'image_generation': [
        {
            'model': 'stable-diffusion',
            'input': 'a red apple on a table',
            'expected_features': ['red_dominant', 'circular_shape'],
            'expected_hash_prefix': 'a3f2'  # 前幾位元應相同
        }
    ]
}
```

## 四、質押 Slashing 機制

### 4.1 懲罰等級

```python
class SlashingManager:
    # 懲罰比例
    PENALTIES = {
        'minor': 0.05,      # 5%
        'moderate': 0.15,   # 15%
        'severe': 0.50,     # 50%
        'critical': 1.00    # 100% (封禁)
    }
    
    def evaluate_offense(self, offense_type, history):
        """評估違規嚴重性"""
        
        # 初犯較輕
        if history.offense_count == 0:
            severity = 'minor'
        
        # 累犯加重
        elif history.offense_count < 3:
            severity = 'moderate'
        
        elif history.offense_count < 5:
            severity = 'severe'
        
        else:
            severity = 'critical'
        
        # 特殊情況
        if offense_type == 'deliberate_fraud':
            severity = 'critical'
        
        return severity
    
    def execute_slash(self, node_id, severity):
        """執行 Slashing"""
        penalty_ratio = self.PENALTIES[severity]
        staked_amount = get_staked_amount(node_id)
        
        slash_amount = staked_amount * penalty_ratio
        
        # 扣除質押
        reduce_stake(node_id, slash_amount)
        
        # 分配 Slashed Coin
        burn_amount = slash_amount * 0.5
        reserve_amount = slash_amount * 0.5
        
        burn_vcoin(burn_amount)
        transfer_to_reserve(reserve_amount)
        
        # 記錄
        log_slashing_event(node_id, severity, slash_amount)
        
        # 如果質押低於最低要求，暫停節點
        if get_staked_amount(node_id) < MIN_STAKE:
            suspend_node(node_id)
```

### 4.2 違規判定流程

```python
def handle_cheating_detection(node_id, evidence):
    """處理作弊檢測"""
    
    # 1. 收集證據
    evidence_score = evaluate_evidence(evidence)
    
    # 2. 交叉驗證
    if evidence_score > 0.7:
        # 增加驗證率
        validate_recent_tasks(node_id, sample_rate=0.5)
    
    # 3. 確認作弊
    if confirmed_cheating(node_id):
        history = get_offense_history(node_id)
        severity = slashing_manager.evaluate_offense(
            evidence.type, 
            history
        )
        
        # 4. 執行懲罰
        slashing_manager.execute_slash(node_id, severity)
        
        # 5. 更新信譽
        reputation_manager.update_on_failure(node_id, severity)
        
        # 6. 通知
        notify_node(node_id, f"檢測到作弊行為，質押已被扣除 {severity}")
```

## 五、防女巫攻擊

### 5.1 身份驗證

```python
class SybilDefense:
    def verify_node_uniqueness(self, node_registration):
        """驗證節點唯一性"""
        
        # 1. GPU 硬體指紋
        gpu_fingerprint = extract_gpu_fingerprint(node_registration)
        if self.is_duplicate_gpu(gpu_fingerprint):
            return False, "GPU 已被其他節點註冊"
        
        # 2. 網路指紋
        network_info = node_registration.network
        if self.detect_same_network(network_info):
            # 允許同一網路多個 GPU，但限制數量
            same_network_count = count_nodes_in_network(network_info)
            if same_network_count > MAX_NODES_PER_NETWORK:
                return False, "同一網路節點數量超過限制"
        
        # 3. 質押要求
        if node_registration.stake < MIN_STAKE:
            return False, "質押金額不足"
        
        return True, "驗證通過"
    
    def extract_gpu_fingerprint(self, registration):
        """提取 GPU 指紋"""
        return {
            'pci_bus_id': registration.gpu.pci_bus_id,
            'serial_number': registration.gpu.serial,
            'uuid': registration.gpu.uuid,
            'vbios_version': registration.gpu.vbios
        }
```

### 5.2 行為模式分析

```python
def detect_coordinated_behavior(nodes):
    """檢測協同作弊"""
    
    # 檢測是否同時提交類似結果
    for time_window in get_time_windows():
        tasks_in_window = get_tasks_in_window(time_window)
        
        # 計算結果相似度矩陣
        similarity_matrix = compute_similarity_matrix(
            [t.result for t in tasks_in_window]
        )
        
        # 檢測異常高相似度
        suspicious_pairs = find_suspicious_pairs(
            similarity_matrix, 
            threshold=0.98
        )
        
        if len(suspicious_pairs) > 5:
            # 可能是協同作弊
            alert_admin(f"檢測到可能的協同作弊: {suspicious_pairs}")
```

## 六、時間攻擊防禦

### 6.1 任務時間戳驗證

```python
def verify_task_timing(task, result):
    """驗證任務執行時間的合理性"""
    
    # 計算理論最小執行時間
    min_time = estimate_min_execution_time(
        task.model,
        task.input_size,
        task.gpu_type
    )
    
    actual_time = result.timestamp - task.assigned_timestamp
    
    # 太快完成 = 可疑
    if actual_time < min_time * 0.5:
        flag_suspicious(task.node_id, 'too_fast')
        increase_validation_rate(task.node_id)
    
    # 太慢完成 = 可能故障
    elif actual_time > min_time * 5:
        flag_suspicious(task.node_id, 'too_slow')
```

### 6.2 任務隨機性

```python
def add_task_randomness(task):
    """為任務添加隨機性，防止預測"""
    
    # 1. 隨機 seed
    task.random_seed = random.randint(0, 2**32)
    
    # 2. 隨機參數微調
    if task.type == 'text_generation':
        task.temperature = random.uniform(0.7, 0.9)
        task.top_p = random.uniform(0.85, 0.95)
    
    # 3. 隨機測試任務混入（節點不知道）
    if random.random() < 0.05:
        task.is_test = True
        task.expected_output = get_known_output(task.input)
    
    return task
```

## 七、監控與告警

### 7.1 異常檢測指標

```python
class AnomalyDetector:
    def monitor_node(self, node_id):
        """持續監控節點行為"""
        metrics = collect_node_metrics(node_id)
        
        alerts = []
        
        # 1. 成功率異常
        if metrics.success_rate < 0.7:
            alerts.append('成功率過低')
        
        # 2. 驗證失敗率
        if metrics.validation_failure_rate > 0.2:
            alerts.append('驗證失敗率過高')
        
        # 3. 執行時間異常
        if metrics.avg_execution_time < metrics.expected_time * 0.3:
            alerts.append('執行時間異常過快')
        
        # 4. 結果相似度異常
        if metrics.result_diversity < 0.1:
            alerts.append('結果缺乏多樣性（可能複製）')
        
        # 5. GPU 利用率異常
        if metrics.gpu_utilization < 0.5:
            alerts.append('GPU 利用率過低（可能虛報）')
        
        if alerts:
            self.trigger_investigation(node_id, alerts)
```

### 7.2 自動回應機制

```python
def auto_response_to_anomaly(node_id, anomaly_type):
    """根據異常類型自動回應"""
    
    if anomaly_type == 'validation_failure':
        # 增加驗證率至 50%
        set_validation_rate(node_id, 0.5)
        
    elif anomaly_type == 'repeated_failures':
        # 暫停新任務分配
        pause_task_assignment(node_id)
        # 發送警告
        send_warning(node_id)
        
    elif anomaly_type == 'confirmed_cheating':
        # 立即封禁
        ban_node(node_id)
        # 執行 Slashing
        slash_stake(node_id, severity='severe')
        # 重新驗證歷史任務
        revalidate_history(node_id, days=7)
```

## 八、人工審查機制

### 8.1 爭議處理

```python
class DisputeResolution:
    def handle_dispute(self, node_id, dispute):
        """處理節點申訴"""
        
        # 1. 收集完整證據
        evidence = {
            'original_task': get_task(dispute.task_id),
            'node_result': get_result(dispute.task_id),
            'validation_results': get_validations(dispute.task_id),
            'node_history': get_node_history(node_id)
        }
        
        # 2. 人工審查
        admin_decision = await admin_review(evidence)
        
        # 3. 處理結果
        if admin_decision == 'node_correct':
            # 恢復信譽
            restore_reputation(node_id)
            # 退還被扣質押
            refund_slashed_stake(node_id)
            
        elif admin_decision == 'validation_error':
            # 補償節點
            compensate_node(node_id)
            # 改進驗證系統
            improve_validator()
            
        else:
            # 維持原判
            log_dispute_rejected(dispute)
```

## 九、長期優化

### 9.1 機器學習防作弊

```python
class MLFraudDetector:
    def train_model(self):
        """訓練作弊檢測模型"""
        features = [
            'execution_time_ratio',
            'validation_success_rate',
            'result_diversity',
            'gpu_utilization',
            'network_latency',
            'task_acceptance_rate'
        ]
        
        # 使用歷史標記資料訓練
        X, y = load_labeled_data()
        self.model = train_classifier(X, y, features)
    
    def predict_fraud_probability(self, node_id):
        """預測作弊機率"""
        features = extract_features(node_id)
        fraud_prob = self.model.predict_proba(features)
        
        if fraud_prob > 0.8:
            trigger_deep_investigation(node_id)
```

### 9.2 社群舉報

```python
def community_report(reporter_id, reported_id, evidence):
    """允許節點舉報其他節點"""
    
    # 驗證舉報者信譽
    if get_reputation(reporter_id) < 80:
        return "信譽不足，無法舉報"
    
    # 記錄舉報
    report = {
        'reporter': reporter_id,
        'reported': reported_id,
        'evidence': evidence,
        'timestamp': now()
    }
    
    save_report(report)
    
    # 增加被舉報節點的監控
    increase_monitoring(reported_id)
    
    # 如果舉報屬實，獎勵舉報者
    if verify_report(report):
        reward_reporter(reporter_id, amount=100)
```
